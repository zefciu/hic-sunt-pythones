\abstract{
	Chcąc przedstawić Pythona jako programowalny język programowania omawiam dwa
	zagadnienia: deskryptory i metaklasy. Deskryptory są specjalnymi obiektami
	należącymi do klasy i zmieniającymi sposób dostępu do członków jej
	instancji. Są one wszechobecne w Pythonie i korzystamy z nich nawet o tym
	nie wiedząc. Metaklasy to ,,klasy klas''. Dzięki nim możemy dodać własną
	logikę do procesu tworzenia klas i dziedziczenia. Wykorzystanie tych
	elementów języka pozwoli nam tworzyć obiekty o niedostępnych normalnie
	możliwościach, jednocześnie proste i intuincyjne w obsłudze.
}

Czasami w ramach PR-u różnych trudnych i zawiłych języków programowania słyszymy
pewne przeciwstawienie ,,programowalnych języków programowania'' językom
prostym, ale ,,sztywnym'', nie dającym programiście swobody. Kiedy czynimy
pierwsze kroki w Pythonie, może nam się wydawać, że zalicza się on do tej
drugiej grupy. Nic bardziej mylnego. Pod warstwą prostoty umożliwiającą każdemu
szybkie wdrożenie znajduje się skomplikowany mechanizm, w którym praktycznie
wszystko można zmienić i zastąpić. 

\section{Deskryptory}
Descryptorem jest każdy obiekt, który definiuje metodę \verb|__get__()|.
Dodatkowo deskryptor może definiować też metody \verb|__set__()| i
\verb|__delete__()|. Deskryptory definiujące metodę \verb|__set__()| nazywane są
\emph{deskryptorami danych}, z czym wiąże się nieco inne ich traktowanie.

Algorytm dostępu do atrybutu obiektu jest następujący:
\begin{itemize}
\item
Jeśli \emph{klasa} obiektu zawiera w swoim \verb|__dict__| deskryptor
\emph{danych} pod kluczem o tej nazwie, jest wołana jego właściwa metoda.
\item
Jeśli jest to próba przypisania, zostaje stworzony Jeśli \emph{obiekt} posiada w swoim \verb|__dict__| klucz o tej nazwie,
jest on zwracany.
\item
Jeśli \emph{klasa} posiada atrybut o tej nazwie, sprawdza się, czy jest on
deskryptorem. Jeśli tak --- zwraca się wynik metody \verb|__get__()|. Jeśli nie
--- zwraca się ten atrybut.
\end{itemize}

Algorytm ten może wydawać się zawiły, jednak ma on uzasadnienie. Dzięki temu, że
tylko deskryptory danych mają priorytet nad elementami znajdującymi się w
\verb|__dict__| obiektu.


\section{Metaklasy}

W języku Python wszystko jest obiektem i wszystko też należy do jakiejś klasy.
Klasy są obiektami wywoływalnymi będącymi instancjami klasy \verb|type| (ta
zaś jest instancją samej siebie) lub jej klasy potomnej. \verb|type| jest więc
podstawową metaklasą.
 
Tworzenie własnych metaklas daje nam możliwość dodawania własnej logiki do
procesu tworzenia klas i dziedziczenia. Konstruktor metaklasy przyjmuje cztery
argumenty. Pierwszy: (oznaczać będziemy go \verb|cls| zamiast \verb|self|) to
podobnie jak w przypadku normalnych obiektów konstruowana właśnie klasa. Drugi,
to nazwa klasy. Trzeci (\verb|bases|) to entka klas bazowych. Czwarty - słownik
zawierający zawartych w definicji członków klasy. Tak więc znaną nam dobrze
konstrukcję:
\begin{verbatim}
class MojaKlasa(Bazowa1, Bazowa2):
  klucz1 = wartosc1
  klucz2 = wartosc2
\end{verbatim}
możemy rozumieć, jako cukier syntaktyczny dla:
\begin{verbatim}
MojaKlasa = type('MojaKlasa', (Bazowa1, Bazowa2), {
    'klucz1': wartosc1,
    'klucz2': wartosc2,
})
\end{verbatim}

Wiedząc, w jaki sposób wołany jest konstruktor metaklasy możemy go nadpisać i
dodawać dowolną logikę, która ma być wykonana w momencie tworzenia klas.
